// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package stats_queries

import (
	"context"
	"time"
)

const deleteOldHLL = `-- name: DeleteOldHLL :exec
DELETE
FROM hll_data
WHERE delete_after < NOW()
`

func (q *Queries) DeleteOldHLL(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteOldHLLStmt, deleteOldHLL)
	return err
}

const getActiveHLLMetrics = `-- name: GetActiveHLLMetrics :many
SELECT id, summary, metric_name, window_start, window_end, delete_after, created_at, updated_at, hll FROM hll_data
WHERE window_start >= $1
  AND window_end <= $2
`

type GetActiveHLLMetricsParams struct {
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
}

func (q *Queries) GetActiveHLLMetrics(ctx context.Context, arg GetActiveHLLMetricsParams) ([]HllDatum, error) {
	rows, err := q.query(ctx, q.getActiveHLLMetricsStmt, getActiveHLLMetrics, arg.WindowStart, arg.WindowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HllDatum
	for rows.Next() {
		var i HllDatum
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.MetricName,
			&i.WindowStart,
			&i.WindowEnd,
			&i.DeleteAfter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hll,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDailyStatsSummaries = `-- name: GetAllDailyStatsSummaries :many
SELECT date, "Daily Active Users", "Likes per Day", "Daily Active Likers", "Posts per Day", "Daily Active Posters", "Follows per Day", "Daily Active Followers", "Blocks per Day", "Daily Active Blockers"
FROM daily_stats_summary
ORDER BY date ASC
LIMIT $1
`

func (q *Queries) GetAllDailyStatsSummaries(ctx context.Context, limit int32) ([]DailyStatsSummary, error) {
	rows, err := q.query(ctx, q.getAllDailyStatsSummariesStmt, getAllDailyStatsSummaries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyStatsSummary
	for rows.Next() {
		var i DailyStatsSummary
		if err := rows.Scan(
			&i.Date,
			&i.DailyActiveUsers,
			&i.LikesPerDay,
			&i.DailyActiveLikers,
			&i.PostsPerDay,
			&i.DailyActivePosters,
			&i.FollowsPerDay,
			&i.DailyActiveFollowers,
			&i.BlocksPerDay,
			&i.DailyActiveBlockers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCursor = `-- name: GetCursor :one
SELECT last_cursor
FROM stats_cursors
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetCursor(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getCursorStmt, getCursor)
	var last_cursor int64
	err := row.Scan(&last_cursor)
	return last_cursor, err
}

const getDailyStatsSummary = `-- name: GetDailyStatsSummary :one
SELECT date, "Daily Active Users", "Likes per Day", "Daily Active Likers", "Posts per Day", "Daily Active Posters", "Follows per Day", "Daily Active Followers", "Blocks per Day", "Daily Active Blockers"
FROM daily_stats_summary
WHERE date = $1
`

func (q *Queries) GetDailyStatsSummary(ctx context.Context, date time.Time) (DailyStatsSummary, error) {
	row := q.queryRow(ctx, q.getDailyStatsSummaryStmt, getDailyStatsSummary, date)
	var i DailyStatsSummary
	err := row.Scan(
		&i.Date,
		&i.DailyActiveUsers,
		&i.LikesPerDay,
		&i.DailyActiveLikers,
		&i.PostsPerDay,
		&i.DailyActivePosters,
		&i.FollowsPerDay,
		&i.DailyActiveFollowers,
		&i.BlocksPerDay,
		&i.DailyActiveBlockers,
	)
	return i, err
}

const getHLL = `-- name: GetHLL :one
SELECT id, summary, metric_name, window_start, window_end, delete_after, created_at, updated_at, hll
FROM hll_data
WHERE metric_name = $1
  AND window_start = $2
  AND window_end = $3
`

type GetHLLParams struct {
	MetricName  string    `json:"metric_name"`
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
}

func (q *Queries) GetHLL(ctx context.Context, arg GetHLLParams) (HllDatum, error) {
	row := q.queryRow(ctx, q.getHLLStmt, getHLL, arg.MetricName, arg.WindowStart, arg.WindowEnd)
	var i HllDatum
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.MetricName,
		&i.WindowStart,
		&i.WindowEnd,
		&i.DeleteAfter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hll,
	)
	return i, err
}

const getHLLsByMetricInRange = `-- name: GetHLLsByMetricInRange :many
SELECT id, summary, metric_name, window_start, window_end, delete_after, created_at, updated_at, hll FROM hll_data
WHERE metric_name = $1
  AND window_start >= $2
  AND window_end <= $3
`

type GetHLLsByMetricInRangeParams struct {
	MetricName  string    `json:"metric_name"`
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
}

func (q *Queries) GetHLLsByMetricInRange(ctx context.Context, arg GetHLLsByMetricInRangeParams) ([]HllDatum, error) {
	rows, err := q.query(ctx, q.getHLLsByMetricInRangeStmt, getHLLsByMetricInRange, arg.MetricName, arg.WindowStart, arg.WindowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HllDatum
	for rows.Next() {
		var i HllDatum
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.MetricName,
			&i.WindowStart,
			&i.WindowEnd,
			&i.DeleteAfter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hll,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDailyStatsSummary = `-- name: InsertDailyStatsSummary :exec
INSERT INTO daily_stats_summary (
        date,
        "Daily Active Users",
        "Likes per Day",
        "Daily Active Likers",
        "Posts per Day",
        "Daily Active Posters",
        "Follows per Day",
        "Daily Active Followers",
        "Blocks per Day",
        "Daily Active Blockers"
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (date) DO
UPDATE
SET "Daily Active Users" = EXCLUDED."Daily Active Users",
    "Likes per Day" = EXCLUDED."Likes per Day",
    "Daily Active Likers" = EXCLUDED."Daily Active Likers",
    "Posts per Day" = EXCLUDED."Posts per Day",
    "Daily Active Posters" = EXCLUDED."Daily Active Posters",
    "Follows per Day" = EXCLUDED."Follows per Day",
    "Daily Active Followers" = EXCLUDED."Daily Active Followers",
    "Blocks per Day" = EXCLUDED."Blocks per Day",
    "Daily Active Blockers" = EXCLUDED."Daily Active Blockers"
WHERE daily_stats_summary.date = EXCLUDED.date
`

type InsertDailyStatsSummaryParams struct {
	Date                 time.Time `json:"date"`
	DailyActiveUsers     int64     `json:"Daily Active Users"`
	LikesPerDay          int64     `json:"Likes per Day"`
	DailyActiveLikers    int64     `json:"Daily Active Likers"`
	PostsPerDay          int64     `json:"Posts per Day"`
	DailyActivePosters   int64     `json:"Daily Active Posters"`
	FollowsPerDay        int64     `json:"Follows per Day"`
	DailyActiveFollowers int64     `json:"Daily Active Followers"`
	BlocksPerDay         int64     `json:"Blocks per Day"`
	DailyActiveBlockers  int64     `json:"Daily Active Blockers"`
}

func (q *Queries) InsertDailyStatsSummary(ctx context.Context, arg InsertDailyStatsSummaryParams) error {
	_, err := q.exec(ctx, q.insertDailyStatsSummaryStmt, insertDailyStatsSummary,
		arg.Date,
		arg.DailyActiveUsers,
		arg.LikesPerDay,
		arg.DailyActiveLikers,
		arg.PostsPerDay,
		arg.DailyActivePosters,
		arg.FollowsPerDay,
		arg.DailyActiveFollowers,
		arg.BlocksPerDay,
		arg.DailyActiveBlockers,
	)
	return err
}

const upsertCursor = `-- name: UpsertCursor :exec
INSERT INTO stats_cursors (id, last_cursor, updated_at)
VALUES (1, $1, NOW())
ON CONFLICT (id) DO
UPDATE
SET last_cursor = EXCLUDED.last_cursor,
    updated_at = NOW()
WHERE stats_cursors.id = EXCLUDED.id
`

func (q *Queries) UpsertCursor(ctx context.Context, lastCursor int64) error {
	_, err := q.exec(ctx, q.upsertCursorStmt, upsertCursor, lastCursor)
	return err
}

const upsertHLL = `-- name: UpsertHLL :exec
INSERT INTO hll_data (
        metric_name,
        summary,
        window_start,
        window_end,
        delete_after,
        hll,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (metric_name, window_start, window_end) DO
UPDATE
SET hll = EXCLUDED.hll,
    updated_at = NOW(),
    summary = EXCLUDED.summary
WHERE hll_data.metric_name = EXCLUDED.metric_name
  AND hll_data.window_start = EXCLUDED.window_start
  AND hll_data.window_end = EXCLUDED.window_end
`

type UpsertHLLParams struct {
	MetricName  string    `json:"metric_name"`
	Summary     int64     `json:"summary"`
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
	DeleteAfter time.Time `json:"delete_after"`
	Hll         []byte    `json:"hll"`
}

func (q *Queries) UpsertHLL(ctx context.Context, arg UpsertHLLParams) error {
	_, err := q.exec(ctx, q.upsertHLLStmt, upsertHLL,
		arg.MetricName,
		arg.Summary,
		arg.WindowStart,
		arg.WindowEnd,
		arg.DeleteAfter,
		arg.Hll,
	)
	return err
}
