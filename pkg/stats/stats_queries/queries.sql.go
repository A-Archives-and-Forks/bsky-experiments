// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package stats_queries

import (
	"context"
	"time"
)

const deleteOldHLL = `-- name: DeleteOldHLL :exec
DELETE
FROM hll_data
WHERE delete_after < NOW()
`

func (q *Queries) DeleteOldHLL(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteOldHLLStmt, deleteOldHLL)
	return err
}

const getActiveHLLMetrics = `-- name: GetActiveHLLMetrics :many
SELECT id, summary, metric_name, window_start, window_end, delete_after, created_at, updated_at, hll FROM hll_data
WHERE window_start >= $1
  AND window_end <= $2
`

type GetActiveHLLMetricsParams struct {
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
}

func (q *Queries) GetActiveHLLMetrics(ctx context.Context, arg GetActiveHLLMetricsParams) ([]HllDatum, error) {
	rows, err := q.query(ctx, q.getActiveHLLMetricsStmt, getActiveHLLMetrics, arg.WindowStart, arg.WindowEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HllDatum
	for rows.Next() {
		var i HllDatum
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.MetricName,
			&i.WindowStart,
			&i.WindowEnd,
			&i.DeleteAfter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hll,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCursor = `-- name: GetCursor :one
SELECT last_cursor
FROM stats_cursors
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetCursor(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getCursorStmt, getCursor)
	var last_cursor int64
	err := row.Scan(&last_cursor)
	return last_cursor, err
}

const getDailyStatsSummary = `-- name: GetDailyStatsSummary :one
SELECT date, "Likes per Day", "Daily Active Likers", "Daily Active Posters", "Posts per Day", "Posts with Images per Day", "Images per Day", "Images with Alt Text per Day", "First Time Posters", "Follows per Day", "Daily Active Followers", "Blocks per Day", "Daily Active Blockers"
FROM daily_stats_summary
WHERE date = $1
`

func (q *Queries) GetDailyStatsSummary(ctx context.Context, date time.Time) (DailyStatsSummary, error) {
	row := q.queryRow(ctx, q.getDailyStatsSummaryStmt, getDailyStatsSummary, date)
	var i DailyStatsSummary
	err := row.Scan(
		&i.Date,
		&i.LikesPerDay,
		&i.DailyActiveLikers,
		&i.DailyActivePosters,
		&i.PostsPerDay,
		&i.PostsWithImagesPerDay,
		&i.ImagesPerDay,
		&i.ImagesWithAltTextPerDay,
		&i.FirstTimePosters,
		&i.FollowsPerDay,
		&i.DailyActiveFollowers,
		&i.BlocksPerDay,
		&i.DailyActiveBlockers,
	)
	return i, err
}

const getHLL = `-- name: GetHLL :one
SELECT id, summary, metric_name, window_start, window_end, delete_after, created_at, updated_at, hll
FROM hll_data
WHERE metric_name = $1
  AND window_start = $2
  AND window_end = $3
`

type GetHLLParams struct {
	MetricName  string    `json:"metric_name"`
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
}

func (q *Queries) GetHLL(ctx context.Context, arg GetHLLParams) (HllDatum, error) {
	row := q.queryRow(ctx, q.getHLLStmt, getHLL, arg.MetricName, arg.WindowStart, arg.WindowEnd)
	var i HllDatum
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.MetricName,
		&i.WindowStart,
		&i.WindowEnd,
		&i.DeleteAfter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hll,
	)
	return i, err
}

const insertDailyStatsSummary = `-- name: InsertDailyStatsSummary :exec
INSERT INTO daily_stats_summary (
        date,
        "Likes per Day",
        "Daily Active Likers",
        "Daily Active Posters",
        "Posts per Day",
        "Posts with Images per Day",
        "Images per Day",
        "Images with Alt Text per Day",
        "First Time Posters",
        "Follows per Day",
        "Daily Active Followers",
        "Blocks per Day",
        "Daily Active Blockers"
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT (date) DO
UPDATE
SET "Likes per Day" = EXCLUDED."Likes per Day",
    "Daily Active Likers" = EXCLUDED."Daily Active Likers",
    "Daily Active Posters" = EXCLUDED."Daily Active Posters",
    "Posts per Day" = EXCLUDED."Posts per Day",
    "Posts with Images per Day" = EXCLUDED."Posts with Images per Day",
    "Images per Day" = EXCLUDED."Images per Day",
    "Images with Alt Text per Day" = EXCLUDED."Images with Alt Text per Day",
    "First Time Posters" = EXCLUDED."First Time Posters",
    "Follows per Day" = EXCLUDED."Follows per Day",
    "Daily Active Followers" = EXCLUDED."Daily Active Followers",
    "Blocks per Day" = EXCLUDED."Blocks per Day",
    "Daily Active Blockers" = EXCLUDED."Daily Active Blockers"
WHERE daily_stats_summary.date = EXCLUDED.date
`

type InsertDailyStatsSummaryParams struct {
	Date                    time.Time `json:"date"`
	LikesPerDay             int64     `json:"Likes per Day"`
	DailyActiveLikers       int64     `json:"Daily Active Likers"`
	DailyActivePosters      int64     `json:"Daily Active Posters"`
	PostsPerDay             int64     `json:"Posts per Day"`
	PostsWithImagesPerDay   int64     `json:"Posts with Images per Day"`
	ImagesPerDay            int64     `json:"Images per Day"`
	ImagesWithAltTextPerDay int64     `json:"Images with Alt Text per Day"`
	FirstTimePosters        int64     `json:"First Time Posters"`
	FollowsPerDay           int64     `json:"Follows per Day"`
	DailyActiveFollowers    int64     `json:"Daily Active Followers"`
	BlocksPerDay            int64     `json:"Blocks per Day"`
	DailyActiveBlockers     int64     `json:"Daily Active Blockers"`
}

func (q *Queries) InsertDailyStatsSummary(ctx context.Context, arg InsertDailyStatsSummaryParams) error {
	_, err := q.exec(ctx, q.insertDailyStatsSummaryStmt, insertDailyStatsSummary,
		arg.Date,
		arg.LikesPerDay,
		arg.DailyActiveLikers,
		arg.DailyActivePosters,
		arg.PostsPerDay,
		arg.PostsWithImagesPerDay,
		arg.ImagesPerDay,
		arg.ImagesWithAltTextPerDay,
		arg.FirstTimePosters,
		arg.FollowsPerDay,
		arg.DailyActiveFollowers,
		arg.BlocksPerDay,
		arg.DailyActiveBlockers,
	)
	return err
}

const upsertCursor = `-- name: UpsertCursor :exec
INSERT INTO stats_cursors (id, last_cursor, updated_at)
VALUES (1, $1, NOW())
ON CONFLICT (id) DO
UPDATE
SET last_cursor = EXCLUDED.last_cursor,
    updated_at = NOW()
WHERE stats_cursors.id = EXCLUDED.id
`

func (q *Queries) UpsertCursor(ctx context.Context, lastCursor int64) error {
	_, err := q.exec(ctx, q.upsertCursorStmt, upsertCursor, lastCursor)
	return err
}

const upsertHLL = `-- name: UpsertHLL :exec
INSERT INTO hll_data (
        metric_name,
        summary,
        window_start,
        window_end,
        delete_after,
        hll,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (metric_name, window_start, window_end) DO
UPDATE
SET hll = EXCLUDED.hll,
    updated_at = NOW(),
    summary = EXCLUDED.summary
WHERE hll_data.metric_name = EXCLUDED.metric_name
  AND hll_data.window_start = EXCLUDED.window_start
  AND hll_data.window_end = EXCLUDED.window_end
`

type UpsertHLLParams struct {
	MetricName  string    `json:"metric_name"`
	Summary     int64     `json:"summary"`
	WindowStart time.Time `json:"window_start"`
	WindowEnd   time.Time `json:"window_end"`
	DeleteAfter time.Time `json:"delete_after"`
	Hll         []byte    `json:"hll"`
}

func (q *Queries) UpsertHLL(ctx context.Context, arg UpsertHLLParams) error {
	_, err := q.exec(ctx, q.upsertHLLStmt, upsertHLL,
		arg.MetricName,
		arg.Summary,
		arg.WindowStart,
		arg.WindowEnd,
		arg.DeleteAfter,
		arg.Hll,
	)
	return err
}
