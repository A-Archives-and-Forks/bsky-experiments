package migrate

import (
	"context"
	"embed"
	"fmt"
	"io"
	"log/slog"
	"net/url"
	"strings"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/clickhouse"
	"github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var migrationsFS embed.FS

// Config holds ClickHouse connection configuration
type Config struct {
	Address  string // host:port
	Username string
	Password string
	Database string
}

// Migrator handles ClickHouse schema migrations
type Migrator struct {
	config Config
	dsn    string
	logger *slog.Logger
}

// NewMigrator creates a new migrator instance from individual config values
func NewMigrator(cfg Config, logger *slog.Logger) *Migrator {
	if cfg.Database == "" {
		cfg.Database = "default"
	}
	if cfg.Address == "" {
		cfg.Address = "localhost:9000"
	}
	if cfg.Username == "" {
		cfg.Username = "default"
	}

	// Build DSN for golang-migrate: clickhouse://host:port?database=db&username=user&password=pass
	// URL-encode username and password to handle special characters
	dsn := fmt.Sprintf("clickhouse://%s?database=%s&username=%s&password=%s&x-multi-statement=true",
		cfg.Address, cfg.Database, url.QueryEscape(cfg.Username), url.QueryEscape(cfg.Password))

	return &Migrator{config: cfg, dsn: dsn, logger: logger}
}

// Up runs all pending migrations
func (m *Migrator) Up() error {
	migrator, err := m.createMigrator()
	if err != nil {
		return err
	}
	defer migrator.Close()

	if err := migrator.Up(); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("migration failed: %w", err)
	}

	version, dirty, err := migrator.Version()
	if err != nil && err != migrate.ErrNilVersion {
		m.logger.Warn("could not get migration version", "error", err)
	} else {
		m.logger.Info("migrations complete", "version", version, "dirty", dirty)
	}

	return nil
}

// Down rolls back the specified number of migrations
func (m *Migrator) Down(steps int) error {
	migrator, err := m.createMigrator()
	if err != nil {
		return err
	}
	defer migrator.Close()

	if err := migrator.Steps(-steps); err != nil && err != migrate.ErrNoChange {
		return fmt.Errorf("rollback failed: %w", err)
	}

	version, dirty, err := migrator.Version()
	if err != nil && err != migrate.ErrNilVersion {
		m.logger.Warn("could not get migration version", "error", err)
	} else {
		m.logger.Info("rollback complete", "version", version, "dirty", dirty)
	}

	return nil
}

// Version returns the current migration version
func (m *Migrator) Version() (uint, bool, error) {
	migrator, err := m.createMigrator()
	if err != nil {
		return 0, false, err
	}
	defer migrator.Close()

	return migrator.Version()
}

// Force sets the migration version without running migrations
// Use this to fix a dirty state
func (m *Migrator) Force(version int) error {
	migrator, err := m.createMigrator()
	if err != nil {
		return err
	}
	defer migrator.Close()

	if err := migrator.Force(version); err != nil {
		return fmt.Errorf("force version failed: %w", err)
	}

	m.logger.Info("forced migration version", "version", version)
	return nil
}

func (m *Migrator) createMigrator() (*migrate.Migrate, error) {
	d, err := iofs.New(migrationsFS, "migrations")
	if err != nil {
		return nil, fmt.Errorf("failed to create migration source: %w", err)
	}

	migrator, err := migrate.NewWithSourceInstance("iofs", d, m.dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to create migrator: %w", err)
	}

	return migrator, nil
}

// DumpSchema queries ClickHouse for all tables/views and outputs CREATE statements
func (m *Migrator) DumpSchema(ctx context.Context, w io.Writer) error {
	opts := &clickhouse.Options{
		Addr: []string{m.config.Address},
		Auth: clickhouse.Auth{
			Database: m.config.Database,
			Username: m.config.Username,
			Password: m.config.Password,
		},
	}

	conn, err := clickhouse.Open(opts)
	if err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}
	defer conn.Close()

	// Get migration version
	version, dirty, verr := m.Version()

	// Write header
	fmt.Fprintf(w, "-- Schema for database: %s\n", m.config.Database)
	if verr == nil {
		fmt.Fprintf(w, "-- Migration version: %d (dirty: %v)\n", version, dirty)
	}
	fmt.Fprintf(w, "-- Generated by: just migrate-dump-schema\n")
	fmt.Fprintln(w)

	// Get all tables (excluding system tables and migration tracking)
	tables, err := m.getTables(ctx, conn)
	if err != nil {
		return err
	}

	// Group by type
	var baseTables, views, matViews []tableInfo
	for _, t := range tables {
		switch {
		case strings.Contains(t.engine, "View"):
			if strings.HasPrefix(t.engine, "Materialized") {
				matViews = append(matViews, t)
			} else {
				views = append(views, t)
			}
		default:
			baseTables = append(baseTables, t)
		}
	}

	// Output tables first
	if len(baseTables) > 0 {
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w, "-- TABLES")
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w)
		for _, t := range baseTables {
			if err := m.writeCreateStatement(ctx, conn, w, t.name); err != nil {
				return err
			}
		}
	}

	// Output views
	if len(views) > 0 {
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w, "-- VIEWS")
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w)
		for _, t := range views {
			if err := m.writeCreateStatement(ctx, conn, w, t.name); err != nil {
				return err
			}
		}
	}

	// Output materialized views
	if len(matViews) > 0 {
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w, "-- MATERIALIZED VIEWS")
		fmt.Fprintln(w, "-- ============================================================================")
		fmt.Fprintln(w)
		for _, t := range matViews {
			if err := m.writeCreateStatement(ctx, conn, w, t.name); err != nil {
				return err
			}
		}
	}

	return nil
}

type tableInfo struct {
	name   string
	engine string
}

func (m *Migrator) getTables(ctx context.Context, conn clickhouse.Conn) ([]tableInfo, error) {
	query := `
		SELECT name, engine
		FROM system.tables
		WHERE database = ?
		  AND name NOT LIKE '.%'
		  AND name != 'schema_migrations'
		ORDER BY
			CASE
				WHEN engine LIKE '%View%' THEN 1
				ELSE 0
			END,
			name
	`

	rows, err := conn.Query(ctx, query, m.config.Database)
	if err != nil {
		return nil, fmt.Errorf("failed to query tables: %w", err)
	}
	defer rows.Close()

	var tables []tableInfo
	for rows.Next() {
		var t tableInfo
		if err := rows.Scan(&t.name, &t.engine); err != nil {
			return nil, fmt.Errorf("failed to scan table: %w", err)
		}
		tables = append(tables, t)
	}

	return tables, nil
}

func (m *Migrator) writeCreateStatement(ctx context.Context, conn clickhouse.Conn, w io.Writer, table string) error {
	query := fmt.Sprintf("SHOW CREATE TABLE %s.%s", m.config.Database, table)

	rows, err := conn.Query(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to get CREATE for %s: %w", table, err)
	}
	defer rows.Close()

	if rows.Next() {
		var stmt string
		if err := rows.Scan(&stmt); err != nil {
			return fmt.Errorf("failed to scan CREATE for %s: %w", table, err)
		}
		// Clean up the statement - remove database prefix for portability
		stmt = strings.ReplaceAll(stmt, fmt.Sprintf("%s.", m.config.Database), "")
		fmt.Fprintf(w, "%s;\n\n", stmt)
	}

	return nil
}
