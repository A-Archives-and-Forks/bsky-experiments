// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: events.sql

package store_queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const concludeEvent = `-- name: ConcludeEvent :exec
UPDATE events
SET results = $2,
    concluded_at = $3
WHERE id = $1
`

type ConcludeEventParams struct {
	ID          int64                 `json:"id"`
	Results     pqtype.NullRawMessage `json:"results"`
	ConcludedAt sql.NullTime          `json:"concluded_at"`
}

func (q *Queries) ConcludeEvent(ctx context.Context, arg ConcludeEventParams) error {
	_, err := q.exec(ctx, q.concludeEventStmt, concludeEvent, arg.ID, arg.Results, arg.ConcludedAt)
	return err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO events (
        initiator_did,
        target_did,
        event_type,
        completed_at
    )
VALUES ($1, $2, $3, $4)
`

type CreateEventParams struct {
	InitiatorDid string    `json:"initiator_did"`
	TargetDid    string    `json:"target_did"`
	EventType    string    `json:"event_type"`
	CompletedAt  time.Time `json:"completed_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.exec(ctx, q.createEventStmt, createEvent,
		arg.InitiatorDid,
		arg.TargetDid,
		arg.EventType,
		arg.CompletedAt,
	)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteEventStmt, deleteEvent, id)
	return err
}

const getActiveEventsForInitiator = `-- name: GetActiveEventsForInitiator :many
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE initiator_did = $1
    AND event_type = $2
    AND completed_at > NOW()
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetActiveEventsForInitiatorParams struct {
	InitiatorDid string `json:"initiator_did"`
	EventType    string `json:"event_type"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetActiveEventsForInitiator(ctx context.Context, arg GetActiveEventsForInitiatorParams) ([]Event, error) {
	rows, err := q.query(ctx, q.getActiveEventsForInitiatorStmt, getActiveEventsForInitiator,
		arg.InitiatorDid,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorDid,
			&i.TargetDid,
			&i.EventType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ConcludedAt,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveEventsForTarget = `-- name: GetActiveEventsForTarget :many
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE $1 = target_did
    AND event_type = $2
    AND completed_at > NOW()
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetActiveEventsForTargetParams struct {
	TargetDid string `json:"target_did"`
	EventType string `json:"event_type"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetActiveEventsForTarget(ctx context.Context, arg GetActiveEventsForTargetParams) ([]Event, error) {
	rows, err := q.query(ctx, q.getActiveEventsForTargetStmt, getActiveEventsForTarget,
		arg.TargetDid,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorDid,
			&i.TargetDid,
			&i.EventType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ConcludedAt,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE id = $1
`

func (q *Queries) GetEvent(ctx context.Context, id int64) (Event, error) {
	row := q.queryRow(ctx, q.getEventStmt, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.InitiatorDid,
		&i.TargetDid,
		&i.EventType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.ConcludedAt,
		&i.Results,
	)
	return i, err
}

const getEventsForInitiator = `-- name: GetEventsForInitiator :many
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE initiator_did = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEventsForInitiatorParams struct {
	InitiatorDid string `json:"initiator_did"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (q *Queries) GetEventsForInitiator(ctx context.Context, arg GetEventsForInitiatorParams) ([]Event, error) {
	rows, err := q.query(ctx, q.getEventsForInitiatorStmt, getEventsForInitiator, arg.InitiatorDid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorDid,
			&i.TargetDid,
			&i.EventType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ConcludedAt,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForTarget = `-- name: GetEventsForTarget :many
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE $1 = target_did
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEventsForTargetParams struct {
	TargetDid string `json:"target_did"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetEventsForTarget(ctx context.Context, arg GetEventsForTargetParams) ([]Event, error) {
	rows, err := q.query(ctx, q.getEventsForTargetStmt, getEventsForTarget, arg.TargetDid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorDid,
			&i.TargetDid,
			&i.EventType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ConcludedAt,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsToConclude = `-- name: GetEventsToConclude :many
SELECT id, initiator_did, target_did, event_type, created_at, updated_at, completed_at, concluded_at, results
FROM events
WHERE completed_at < NOW()
    AND results IS NULL
    AND event_type = $1
ORDER BY completed_at ASC
LIMIT $2 OFFSET $3
`

type GetEventsToConcludeParams struct {
	EventType string `json:"event_type"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetEventsToConclude(ctx context.Context, arg GetEventsToConcludeParams) ([]Event, error) {
	rows, err := q.query(ctx, q.getEventsToConcludeStmt, getEventsToConclude, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorDid,
			&i.TargetDid,
			&i.EventType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.ConcludedAt,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
